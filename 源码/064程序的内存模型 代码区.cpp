#include<iostream>
using namespace std;

int a1 = 10;//全局变量 写在函数体之外
int b1 = 20;

const int a3 = 10;
const int b3 = 20;

int main() {
	//c++程序在执行时 将内存大方向分为四个区域
	//代码区 存放函数体的二进制代码 由操作系统管理的
	//全局区 存放全局变量 静态变量 以及 常量
	//栈区 由编译器自动分配释放 存放函数的参数值 局部变量等
	//由程序员分配和释放 若程序员不释放 程序结束时由操作系统回收

	//分成内存四区的意义
	//不同的区域存放的数据 赋予不同的生命周期 给我们更大的灵活编程

	/*程序运行前 
	*	在程序编译后,生成了exe可执行程序 未执行改程序前分为两个区域
	*	代码区:
	*		存放cpu执行的机器指令
	*		代码区是 共享 的,共享的目的是对于频繁执行的程序,只需要在内存中有一份代码即可
	*		代码区是 只读 的,让其只读的原因是防止程序意外的修改了它的指令
	*	
	*	全局区:
	*		全局变量和静态变量存放于此
	*		全局区还包括了常量区 ,字符串常量和其他常量也存放在此(const修饰的变量也是常量哦)
	*		该区域的数据在程序结束由操作系统释放 
	*/

	//局部变量
	int a = 10;
	int b = 20;
	cout << "局部变量a的地址为" << (int)&a << endl; //不在全局区
	cout << "局部变量b的地址为" << (int)&b << endl;//不在全局区
	
	 //全局变量
	cout << "全局变量a1的地址为" << (int)&a1 << endl;//在全局区
	cout << "全局变量b1的地址为" << (int)&b1 << endl;//在全局区

	//静态变量 在普通变量前面加 static ,属于静态变量
	static int a2 = 10;
	static int b2 = 10;

	cout << "静态变量a2的地址为" << (int)&a2 << endl;//在全局区
	cout << "静态变量b2的地址为" << (int)&b2 << endl;//在全局区

	//常量
	//字符串常量
	cout << "字符串常量hl的地址是" << (int)&"hello world" << endl;//在全局区

	//const修饰的变量 分为两种
	//1.const修饰的全局变量 (全局常量)
	cout << "全局常量a3的地址为" << (int)&a3 << endl;//在全局区
	cout << "全局常量b3的地址为" << (int)&b3  << endl;//在全局区

	//2.const修饰的局部变量(局部常量)
	const int a4 = 10;
	const int b4 = 20;
	cout << "局部常量a4的地址为" << (int)&a4 << endl;//不在全局区
	cout << "局部常量b4的地址为" << (int)&b4 << endl;//不在全局区
	
	//通过局部常量和局部变量的地址结果 我们发现 局部的变量常量都不放在全局区中
	//全局常量 字符串常量 全局变量 静态变量都是在全局区之中的

	cout << "-------------------------------------------------------------------------" << endl;


	system("pause");
	return 0;
}
