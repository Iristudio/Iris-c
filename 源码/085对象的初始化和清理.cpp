#include<iostream>
using namespace std;

//对象的初始化和清理是两个重要的安全问题 
//一个对象或变量 没有初始状态 对其使用后果是未知的
//同样使用完一个变量或者对象 没有及时清理也会造成一定的安全问题

//c++利用了 构造函数 和 析构函数 来解决上述问题
//这两个函数还会被编译器自动调用 完成对象的初始化和清理工作 
//对象的初始化 和清理工作 是编译器强制要我们做的事情 
//因此 如果我们不提供构造和析构函数 编译器会提供
//编译器提供的狗在函数和析构函数是空实现

//构造函数 主要作用域创建对象时 为对象的成员属性赋值 构造函数由编译器自动调用 
//析构函数 主要作用在于对象销毁前系统自动调用 执行一些清理工作

class person {
	/*构造函数语法
	  类名(){}
	*1.构造函数 没有返回值也不用写void
	* 2.函数名称与类名相同
	* 3.构造函数可以用参数 因此也可以重载
	* 4.程序在调用对象时会自动调用构造 无需手动调用 而且只会调用一次
	*/
public:
	person() {
		cout << "person的构造函数的调用" << endl;
	}

	/*析构函数语法
	* ~类名*(){}
	* 1.析构函数 没有返回值也不写void
	* 2.函数名称与类名相同 在名称前加上 ~
	* 3.析构函数不可以有参数 因此也不可以发生重载
	* 4.程序在对象销毁前时会自动调用析构 无需手动调用 而且只会调用一次
	*/
	~person() {
		cout << "person的析构函数的调用" << endl;
	}
};
//析构和构造 都是必须有的实现 如果过我们不提供 编译器也提供一个空实现的构造和析构
void test1() {
	person p1;//这是个局部对象 创建在栈上 当test1执行完毕后 就会释放这个对象 也就会调用析构函数 
	//在这里我并没有调用person类中的函数 但是依然会实现person函数
}

	/*析构函数语法
	* ~类名*(){}
	* 1.析构函数 没有返回值也不写void
	* 2.函数名称与类名相同 在名称前加上 ~
	* 3.析构函数不可以有参数 因此也不可以发生重载
	* 4.程序在对象销毁前时会自动调用析构 无需手动调用 而且只会调用一次
	*/

int main() {
	test1();









	system("pause");
	return 0;
}